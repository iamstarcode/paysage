CREATE TABLE public.profiles (
    id uuid not null references auth.users on delete cascade,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    username VARCHAR(50),

    primary key (id)
);

-- CREATE INDEX idx_profile_user_id ON public.profiles(user_id);

alter table public.profiles enable row level security;
create policy "Public profiles are viewable only by authenticated users"
    on public.profiles for select
    to authenticated
    using ( true );

create policy "Users can update own profile."
    on public.profiles for update
    using ( auth.uid() = id );

-- inserts a row into public.profiles
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id)
  values (new.id);

  return new;
end;
$$;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


CREATE TABLE currencies (
    id bigint generated by default as identity primary key,
    currency_name VARCHAR(50) NOT NULL,
    currency_code VARCHAR(3) NOT NULL,
    currency_sign VARCHAR(1)  NOT NULL,
    UNIQUE(currency_code)
);


CREATE TABLE public.wallets (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade not null, -- Reference to the user who owns the wallet
    currency_id INT REFERENCES public.currencies(id),
    balance NUMERIC(20, 2) DEFAULT 0, -- Balance of the currency in the wallet
    UNIQUE(user_id, currency_id) -- Ensure each user has only one wallet per currency
);

alter table public.wallets enable row level security;

create policy "Only Users to create new wallet."
    on public.wallets for insert
    to authenticated 
    with check ( auth.uid() = user_id );

create policy "Only Users can view own wallet."
    on public.wallets for select
    to authenticated 
    using ( auth.uid() = user_id );

create policy "Users can update their own wallet balance."
    on wallets for update
    to authenticated                    
    using ( auth.uid() = user_id )
-- Comtemplate for delete permission

create function public.transfer_funds(sender_id text, receiver_id text, amount numeric)
returns void
security definer set search_path = public
as $$
begin
  -- Check that the sender and receiver IDs are valid
  if not exists (select 1 from wallets where user_id = sender_id) then
    raise exception 'Invalid sender ID: %', sender_id;
  end if;

  if not exists (select 1 from wallets where user_id = receiver_id) then
    raise exception 'Invalid receiver ID: %', receiver_id;
  end if;

  -- Check that the sender has sufficient funds
  if (select balance from wallets where user_id = sender_id) < amount then
    raise exception 'Insufficient funds: %', sender_id;
  end if;

  -- Update the sender's balance
  update wallets
  set balance = balance - amount
  where user_id = sender_id;

  -- Update the receiver's balance
  update wallets
  set balance = balance + amount
  where user_id = receiver_id;
end;
$$ language plpgsql;

grant execute on function public.transfer_funds(text, text, numeric) to authenticated;


CREATE TABLE transactions (
  id SERIAL PRIMARY KEY,
  sender_wallet_id INTEGER REFERENCES public.wallets(id),
  receiver_wallet_id INTEGER REFERENCES public.wallets(id),
  amount NUMERIC(18, 2),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

